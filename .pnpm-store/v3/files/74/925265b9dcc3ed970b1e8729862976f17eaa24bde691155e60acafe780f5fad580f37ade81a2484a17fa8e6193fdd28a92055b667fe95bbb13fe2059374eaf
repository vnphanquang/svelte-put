{"version":3,"file":"ExperimentalYamlDocumenter.js","sourceRoot":"","sources":["../../src/documenters/ExperimentalYamlDocumenter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { DocComment, DocInlineTag } from '@microsoft/tsdoc';\nimport { ApiModel, ApiItem, ApiItemKind, ApiDocumentedItem } from '@microsoft/api-extractor-model';\n\nimport { IConfigTableOfContents } from './IConfigFile';\nimport { IYamlTocItem, IYamlTocFile } from '../yaml/IYamlTocFile';\nimport { YamlDocumenter } from './YamlDocumenter';\nimport { DocumenterConfig } from './DocumenterConfig';\n\n/**\n * EXPERIMENTAL - This documenter is a prototype of a new config file driven mode of operation for\n * API Documenter.  It is not ready for general usage yet.  Its design may change in the future.\n */\nexport class ExperimentalYamlDocumenter extends YamlDocumenter {\n  private _config: IConfigTableOfContents;\n  private _tocPointerMap: { [key: string]: IYamlTocItem };\n  private _catchAllPointer: IYamlTocItem | undefined;\n\n  public constructor(apiModel: ApiModel, documenterConfig: DocumenterConfig) {\n    super(apiModel, documenterConfig.configFile.newDocfxNamespaces);\n    this._config = documenterConfig.configFile.tableOfContents!;\n\n    this._tocPointerMap = {};\n\n    this._generateTocPointersMap(this._config.tocConfig);\n  }\n\n  /** @override */\n  protected buildYamlTocFile(apiItems: ReadonlyArray<ApiItem>): IYamlTocFile {\n    this._buildTocItems2(apiItems);\n    return this._config.tocConfig;\n  }\n\n  private _buildTocItems2(apiItems: ReadonlyArray<ApiItem>): IYamlTocItem[] {\n    const tocItems: IYamlTocItem[] = [];\n    for (const apiItem of apiItems) {\n      let tocItem: IYamlTocItem;\n      if (apiItem.kind === ApiItemKind.Namespace && !this.newDocfxNamespaces) {\n        tocItem = {\n          name: this._getTocItemName(apiItem)\n        };\n      } else {\n        if (this._shouldEmbed(apiItem.kind)) {\n          // Don't generate table of contents items for embedded definitions\n          continue;\n        }\n\n        tocItem = {\n          name: this._getTocItemName(apiItem),\n          uid: this._getUid(apiItem)\n        };\n\n        if (apiItem.kind !== ApiItemKind.Package) {\n          this._filterItem(apiItem, tocItem);\n        }\n      }\n\n      tocItems.push(tocItem);\n\n      const children: ApiItem[] = this._getLogicalChildren(apiItem);\n      const childItems: IYamlTocItem[] = this._buildTocItems2(children);\n      if (childItems.length > 0) {\n        tocItem.items = childItems;\n      }\n    }\n    return tocItems;\n  }\n\n  // Parses the tocConfig object to build a pointers map of nodes where we want to sort out the API items\n  private _generateTocPointersMap(tocConfig: IYamlTocFile | IYamlTocItem): void {\n    const { catchAllCategory } = this._config;\n\n    if (tocConfig.items) {\n      for (const tocItem of tocConfig.items) {\n        if (tocItem.items && tocItem.items.length > 0 && this._shouldNotIncludeInPointersMap(tocItem)) {\n          this._generateTocPointersMap(tocItem);\n        } else {\n          // check for presence of the `catchAllCategory` config option\n          if (catchAllCategory && tocItem.name === catchAllCategory) {\n            this._catchAllPointer = tocItem;\n          } else {\n            this._tocPointerMap[tocItem.name] = tocItem;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Filtering out the api-item by inlineTags or category name presence in the item name.\n   */\n  private _filterItem(apiItem: ApiItem, tocItem: IYamlTocItem): void {\n    const { categoryInlineTag, categorizeByName } = this._config;\n    const { name: itemName } = tocItem;\n    let filtered: boolean = false;\n\n    // First we attempt to filter by inline tag if provided.\n    if (apiItem instanceof ApiDocumentedItem) {\n      const docInlineTag: DocInlineTag | undefined = categoryInlineTag\n        ? this._findInlineTagByName(categoryInlineTag, apiItem.tsdocComment)\n        : undefined;\n\n      const tagContent: string | undefined =\n        docInlineTag && docInlineTag.tagContent && docInlineTag.tagContent.trim();\n\n      if (tagContent && this._tocPointerMap[tagContent]) {\n        // null assertion used because when pointer map was created we checked for presence of empty `items` array\n        this._tocPointerMap[tagContent].items!.push(tocItem);\n        filtered = true;\n      }\n    }\n\n    // If not filtered by inline tag and `categorizeByName` config is enabled attempt to filter it by category name.\n    if (!filtered && categorizeByName) {\n      const pointers: string[] = Object.keys(this._tocPointerMap);\n      for (let i: number = 0, length: number = pointers.length; i < length; i++) {\n        if (itemName.indexOf(pointers[i]) !== -1) {\n          // null assertion used because when pointer map was created we checked for presence of empty `items` array\n          this._tocPointerMap[pointers[i]].items!.push(tocItem);\n          filtered = true;\n          break;\n        }\n      }\n    }\n\n    // If item still not filtered and a `catchAllCategory` config provided push it to it.\n    if (!filtered && this._catchAllPointer && this._catchAllPointer.items) {\n      this._catchAllPointer.items.push(tocItem);\n    }\n  }\n\n  // This is a direct copy of a @docCategory inline tag finder in office-ui-fabric-react,\n  // but is generic enough to be used for any inline tag\n  private _findInlineTagByName(\n    tagName: string,\n    docComment: DocComment | undefined\n  ): DocInlineTag | undefined {\n    const tagNameToCheck: string = `@${tagName}`;\n\n    if (docComment instanceof DocInlineTag) {\n      if (docComment.tagName === tagNameToCheck) {\n        return docComment;\n      }\n    }\n    if (docComment) {\n      for (const childNode of docComment.getChildNodes()) {\n        const result: DocInlineTag | undefined = this._findInlineTagByName(tagName, childNode as DocComment);\n        if (result !== undefined) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private _shouldNotIncludeInPointersMap(item: IYamlTocItem): boolean {\n    const { nonEmptyCategoryNodeNames } = this._config;\n    if (nonEmptyCategoryNodeNames && nonEmptyCategoryNodeNames.length) {\n      return nonEmptyCategoryNodeNames.indexOf(item.name) === -1;\n    }\n    return true;\n  }\n}\n"]}