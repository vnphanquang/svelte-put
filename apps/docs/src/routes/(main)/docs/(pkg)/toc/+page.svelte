<script lang="ts">
  import { ATTRIBUTES } from '@svelte-put/toc/attributes';
  import typescript from 'svelte-highlight/languages/typescript';

  import ActionUsageNotice from '$client/components/ActionUsageNotice/ActionUsageNotice.svelte';
  import ApiReference from '$client/components/ApiReference/ApiReference.svelte';
  import ApiUnitReference from '$client/components/ApiUnitReference/ApiUnitReference.svelte';
  import Code from '$client/components/Code/Code.svelte';
  import { ConnectedList, ConnectedListItem } from '$client/components/ConnectedList';
  import Installation from '$client/components/Installation/Installation.svelte';
  import ResourceLink from '$client/components/ResourceLink/ResourceLink.svelte';
  import endImg from '$shared/assets/images/table-of-contents-cat.webp';

  import type { PageData } from './$types';
  import { codes } from './_page/codes';
  export let data: PageData;
</script>

<section>
  <h2>Acknowledgement</h2>
  <p>
    This package relies on
    <ResourceLink key="svelte action" /> strategy and attempts to stay minimal. If you are looking for
    a declarative, component-oriented solution, check out
    <ResourceLink href="https://github.com/janosh">Janosh</ResourceLink>'s
    <ResourceLink href="https://github.com/janosh/svelte-toc">svelte-toc</ResourceLink>.
  </p>
</section>

<Installation pkg={data.package.name} />

<section>
  <h2>Introduction</h2>
  <p>
    <code>@svelte-put/toc</code> operates at <strong>runtime</strong> and does the following:
  </p>
  <ConnectedList class="pl-4">
    <ConnectedListItem>
      <p>search for matching elements (default: <code>:where(h1, h2, h3, h4, h5, h6)</code>),</p>
    </ConnectedListItem>
    <ConnectedListItem>
      <p>
        generate <code>id</code> attribute from element content,
      </p>
    </ConnectedListItem>
    <ConnectedListItem>
      <p>add anchor tag to element,</p>
    </ConnectedListItem>
    <ConnectedListItem>
      <p>
        attach <ResourceLink key="IntersectionObserver" /> to each matching element to track its visibility
        on the screen,
      </p>
    </ConnectedListItem>
    <ConnectedListItem>
      <p>expose necessary pieces for building table of contents.</p>
    </ConnectedListItem>
  </ConnectedList>
  <p>
    It is recommended to use the complementary <ResourceLink
      key="@svelte-put/preprocess-auto-slug"
    /> for handling
    <span class="c-circle-number-primary">2</span>
    and
    <span class="c-circle-number-primary">3</span> at <strong>build time</strong> when possible.
    <code>toc</code> will skip those operations if they are already handled by
    <code>preprocess-auto-slug</code>.
  </p>
  <p>
    Notice <code>toc</code> relies on <ResourceLink key="IntersectionObserver" /> and not
    <code>on:scroll</code> for better performance and predictability. See <ResourceLink
      href="https://itnext.io/1v1-scroll-listener-vs-intersection-observers-469a26ab9eb6"
    >
      this article
    </ResourceLink> for a performance comparison between <code>on:scroll</code> vs
    <code>IntersectionObserver</code>.
  </p>

  <p class="c-callout-info">
    The table of contents on this documentation site is generated by <code>toc</code> itself. Check
    out the
    <ResourceLink
      href="https://github.com/vnphanquang/svelte-put/blob/main/apps/docs/src/routes/(main)/+layout.svelte#L223-L227"
    >
      source code here.
    </ResourceLink>
  </p>
</section>

<section>
  <h2 id="quick-start">Quick Start</h2>
  <p>
    Given the following svelte component, let's see how <code>toc</code> searches for all headings,
    generates id based on <code>textContent</code>, adds anchor tag, and tracks active element on
    screen.
  </p>
  <Code code={codes.quickStart.input} title="quick start - input" />
  <p>
    Notice the usage of <code>createTocStore</code> as a helper for creating an idiomatic
    <ResourceLink key="svelte store" />, which will populate its <code>items</code> property with
    the extracted toc elements, and track <code>activeItem</code> if <code>observe</code> is set to
    <code>true</code>.
  </p>
  <p>
    Also note the complementary optional <code>toclink</code> used on anchor tags in the table of
    contents. This helps save some manual effort and keep the behavior consistent with the main
    <code>toc</code>
    action. See <ResourceLink id="complementary-toclink-action"
      >Complementary <code>toclink</code></ResourceLink
    >
    for more details.
  </p>
  <Code code={codes.quickStart.output} title="quick start - output" />
</section>

<section>
  <h2>Toc Action</h2>

  <p>
    <code>use:toc</code> will search for matching elements only from descendants of the element
    where it is used. In the <ResourceLink id="quick-start">Quick Start</ResourceLink> example, that's
    the <code>main</code> element. To search from everything on the page, use it on
    <code>svelte:body</code>.
    <!-- add prop online:boolean to the Code component that renders a minimal box -->
    <Code code={`<svelte:body use:toc />`} />
  </p>

  <ActionUsageNotice action={data.package.id}>
    <h3 slot="heading" let:heading>{heading}</h3>
  </ActionUsageNotice>

  <section>
    <h3>Parameters</h3>
    <p>
      <code>toc</code> is highly customizable. Please visit the extracted
      <ResourceLink
        href="https://github.com/vnphanquang/svelte-put/blob/main/packages/actions/toc/api/docs/toc.tocparameters.md"
      >
        TocParameters
      </ResourceLink> API page for details.
    </p>
  </section>

  <section>
    <h3>No Dynamic Update</h3>
    <p>
      During development, you may notice that <code>toc</code> does not update when you change the
      action parameters at runtime and requires a page refresh to work again. This is because
      currently
      <code>toc</code> only runs once on mount.
    </p>
    <p>
      Supporting dynamic update is quite a heavy task (tracking what's changed and avoiding
      duplicated operations) that will increase the bundle size & complexity but is not very useful
      in most use cases (how often does a table of contents change at runtime?).
    </p>
    <p>
      If you think otherwise and have a valid use case, please submit an
      <ResourceLink key="issue" />.
    </p>
  </section>
</section>

<section>
  <h2>Events</h2>
  <p>
    In <ResourceLink id="quick-start">Quick Start</ResourceLink>,
    <ResourceLink key="svelte store" /> is used to keep code minimal. Alternatively, you can listen for
    <code>tocinit</code> and <code>tocchange</code> events.
  </p>
  <Code code={codes.events.example} title="toc events" />

  <section>
    <h3>Runtime Expectation</h3>
    <p>
      <code>tocinit</code> is only fired once. And whether <code>tocchange</code> is fired depends
      on the
      <code>observe</code> action parameter (discussed in
      <ResourceLink id="observing-in-view-element">Observing 'In View' Element</ResourceLink>
      ).
    </p>
    <ul>
      <li>
        When <code>observe</code> is <code>false</code>, expect no <code>tocchange</code> event. This
        makes sense because all necessary information has been extracted at initialization.
      </li>
      <li>
        When <code>observe</code> is <code>true</code>, expect a <code>tocchange</code> event that
        follows shortly after <code>tocinit</code>. The <code>observe</code> property of each
        extracted <ResourceLink
          href="https://github.com/vnphanquang/svelte-put/blob/main/packages/actions/toc/api/docs/toc.tocitem.md"
          >TocItem</ResourceLink
        > is only guaranteed to be populated in this
        <code>tocchange</code> event and not <code>tocinit</code>. This is because
        <code>observe</code>
        initialization operations are run asynchronously to avoid blocking any potential work with the
        extracted information from <code>tocinit</code> (such as rendering the table of content itself).
      </li>
    </ul>
  </section>

  <section>
    <h3>Typescript Support</h3>
    <p>
      Ambient types for custom events should be available automatically where <code
        >{data.package.id}</code
      > is imported.
    </p>
    <Code
      lang="svelte"
      code={codes.events.typing.auto}
      title="automatically typed - example source"
      expanded={false}
    />
    <p>If the above is not working, fall back to this:</p>
    <Code
      lang={typescript}
      code={codes.events.typing.fallback}
      title="src/app.d.ts - fallback typescript support"
      expanded={false}
    />
  </section>
</section>

<section>
  <h2 id="observing-in-view-element">Observing 'In View' Element</h2>
  <p>
    A common feature of a table of contents on the web is to track which part is "in view".
    Traditionally this has been done with <code>on:scroll</code>, but with the relatively new
    <ResourceLink key="IntersectionObserver" />, we can do this in a more performant way.
  </p>
  <section>
    <h3>Caveat</h3>
    <p>
      Unfortunately <code>IntersectionObserver</code> comes with its own caveat. For
      <code>on:scroll</code>, we can achieve something like:
    </p>
    <blockquote style="quotes: none;">
      <p>
        For an element (typically heading), when it reach 10% offset of screen from the top, set it
        as active.
      </p>
    </blockquote>
    <p>
      This is not trivial with <code>IntersectionObserver</code> without some hacking (to my
      knowledge at least), because
      <code>IntersectionObserver</code> triggers when element (or part of it) intersects with
      viewport. For this reason, <code>toc</code> prefers to "think" in terms of "section" rather than
      individual element, something like this:
    </p>
    <blockquote style="quotes: none;">
      <p>
        When 80% of a "section" is visible within the viewport (threshold of <code>0.8</code> for
        <code>IntersectionObserver</code>), set it to active.
      </p>
    </blockquote>
    <p>
      With this design decision, a typical use case is wrapping heading tags within a <code
        >section</code
      >
      or <code>div</code> (as shown in <ResourceLink id="quick-start">Quick Start</ResourceLink>).
    </p>
    <Code code={codes.caveat.prefer} title="think in terms of section" icon="info" />
    <Code code={codes.caveat.avoid} title="rather than flat individual elements" icon="error" />
    <p>
      You might also find that when an anchor linked to a matching toc element being clicked on (to
      scroll to said element), the toc element might not be the active one. This is explained with
      with idiomatic solution in <ResourceLink id="complementary-toclink-action"
        >toclink</ResourceLink
      >.
    </p>
  </section>
  <section>
    <h3>Observe Customization</h3>
    <p>
      In <code>toc</code>, this feature is turned off by default. To use it, set the
      <code>toc</code>
      action parameter <code>observe</code> to <code>true</code> or provide an object with customization
      options.
    </p>
    <Code code={codes.observe} title="turn on observe feature" />

    <ApiUnitReference type="'parent' | 'self' | 'auto'" d="'auto'">
      <h4 slot="name" id="observe.strategy"><code>observe.strategy</code></h4>
      <p>
        This option affects which element the <ResourceLink key="IntersectionObserver" /> will observe.
      </p>
      <ul>
        <li>
          <code>parent</code>: observe <code>parentElement</code> of the matching toc element,
        </li>
        <li><code>self</code>: observe the matching toc element itself,</li>
        <li>
          <code>auto</code>: attempt to compare matching toc element & its parent
          <code>offsetHeight</code> with <code>window.innerHeight</code> to determine the best strategy.
        </li>
      </ul>
      <p>
        Alternatively, <ResourceLink id={ATTRIBUTES.strategy}>{ATTRIBUTES.strategy}</ResourceLink>
        can be set on the matching toc element to override this global settings.
      </p>
    </ApiUnitReference>

    <ApiUnitReference
      type="number | ((element: HTMLElement) => number)"
      d="(element) => Math.min((0.8 * window.innerHeight) / element.offsetHeight, 1)"
    >
      <h4 slot="name" id="observe.threshold"><code>observe.threshold</code></h4>
      <p>The threshold passed to <ResourceLink key="IntersectionObserver" />.</p>
      <p>
        Alternatively, <ResourceLink id={ATTRIBUTES.threshold}>{ATTRIBUTES.threshold}</ResourceLink>
        can be set on the matching toc element to override this global settings.
      </p>
    </ApiUnitReference>

    <ApiUnitReference type="boolean" d="false">
      <h4 slot="name" id="observe.enabled"><code>observe.enabled</code></h4>
      <p>
        Whether to turn on <code>observe</code> feature. When <code>observe</code>
        is provided as an object, this is <code>true</code> implicitly.
      </p>
    </ApiUnitReference>
  </section>
</section>

<section>
  <h2 id="complementary-toclink-action">Complementary <code>toclink</code> Action</h2>
  <p>
    As seen in <ResourceLink id="quick-start">Quick Start</ResourceLink>:
  </p>
  <Code code={codes.toclink.usage} title="toclink" />
  <p>Regarding markup, this is essentially the same as:</p>
  <Code code={codes.toclink.equivalence} title="toclink - markup equivalence" />
  <p>
    However, <code>toclink</code> provides additional click listener that makes sure the toc item being
    clicked on will be the active one.
  </p>
  <p class="c-callout-warning">
    This is not always guaranteed otherwise, because toc relies on
    <code>IntersectionObserver</code>, and when a matching toc element is scrolled into view, the
    next one might already intersects with the viewport and become the active one.
  </p>

  <p>
    For customization details, see the
    <ResourceLink
      href="https://github.com/vnphanquang/svelte-put/blob/main/packages/actions/toc/api/docs/toc.toclink.md"
      >extracted API page</ResourceLink
    >.
  </p>
</section>

<section>
  <h2>Toc Data Attributes</h2>

  <p>
    Attributes listed below can be used to override behavior of <code>toc</code>
    per matching element. All of them are <code>undefined</code> by default.
  </p>

  <ApiUnitReference type="boolean">
    <h3 slot="name" id={ATTRIBUTES.ignore}><code>{ATTRIBUTES.ignore}</code></h3>
    <p>Whether to ignore this element when searching for matching elements.</p>
  </ApiUnitReference>

  <ApiUnitReference type="string">
    <h3 slot="name" id={ATTRIBUTES.id}><code>{ATTRIBUTES.id}</code></h3>
    <p>
      The <code>id</code> to use for this element in <code>toc</code> context. If not provided, this
      will be the element <code>id</code>, or generated by <code>toc</code>
      if element does not have an <code>id</code> either.
    </p>
  </ApiUnitReference>

  <ApiUnitReference type="'parent' | 'self' | 'auto'">
    <h3 slot="name" id={ATTRIBUTES.strategy}><code>{ATTRIBUTES.strategy}</code></h3>
    <p>
      Override the <code>strategy</code> for this element to use in creating
      <ResourceLink key="IntersectionObserver" />. This only has effect if the <code>observe</code>
      option is enabled in <code>toc</code> parameters.
    </p>
  </ApiUnitReference>

  <ApiUnitReference type="number">
    <h3 slot="name" id={ATTRIBUTES.threshold}>{ATTRIBUTES.threshold}</h3>
    <p>
      Override the <code>threshold</code> for this element to use in creating
      <ResourceLink key="IntersectionObserver" />. This only has effect if the <code>observe</code>
      option is enabled in <code>toc</code> parameters.
    </p>
  </ApiUnitReference>

  <p>
    These attributes are also be referenced from the extracted
    <ResourceLink
      href="https://github.com/vnphanquang/svelte-put/blob/main/packages/actions/toc/api/docs/toc.tocdataattributes.md"
    >
      TocDataAttributes
    </ResourceLink> API page.
  </p>

  <p>Below instructions show how to add type support for these attributes</p>
  <Code code={codes.dataAttributes} title="app.d.ts" />

  <hr />

  <p>
    The following attributes are utilized by the <code>observe</code>
    operation when enabled.
  </p>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.observeFor}><code>{ATTRIBUTES.observeFor}</code></h3>
    <p>
      Added to the element where <code>IntersectionObserver</code>
      is used when <code>observe</code> is used and references the associated toc element.
    </p>
  </ApiUnitReference>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.observeActiveId}><code>{ATTRIBUTES.observeActiveId}</code></h3>
    <p>
      Added to the element where <code>toc</code> action is used and references the <code>id</code> of
      the active matching element.
    </p>
    <p class="c-callout-info">
      This attribute is reactive. When changed, it will trigger events and store update.
    </p>
  </ApiUnitReference>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.observeThrottled}><code>{ATTRIBUTES.observeThrottled}</code></h3>
    <p>
      Added to the element where <code>toc</code> action is used to indicate whether
      <code>observe</code>
      is being throttled, typically in conjunction with usage of <code>toclink</code> action.
    </p>
  </ApiUnitReference>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.linkActive}><code>{ATTRIBUTES.linkActive}</code></h3>
    <p>
      Added to the element where <code>toclink</code> is used and set to <code>true</code>
      when the linked toc element is active.
    </p>
  </ApiUnitReference>

  <hr />

  <p>The following attributes act as <strong>readonly</strong> reference markers.</p>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.toc}><code>{ATTRIBUTES.toc}</code></h3>
    <p>
      Marking this element that it's been processed by <code>toc</code>.
    </p>
    <p>
      If this is already preprocessed by <ResourceLink key="@svelte-put/preprocess-auto-slug" />,
      there will also be a <code>{ATTRIBUTES.autoslug}</code> attribute.
    </p>
  </ApiUnitReference>

  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.anchor}><code>{ATTRIBUTES.anchor}</code></h3>
    <p>
      If the <code>anchor</code> option is enabled in <code>toc</code> parameters, this attribute is
      present on the injected anchor element.
    </p>
    <p>
      If the element is added by <ResourceLink key="@svelte-put/preprocess-auto-slug" />, the
      <code>{ATTRIBUTES.autoSlugAnchor}</code> can be seen instead.
    </p>
  </ApiUnitReference>

  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.root}><code>{ATTRIBUTES.root}</code></h3>
    <p>
      This attribute is added to the element where <code>toc</code> action is used for internal reference.
    </p>
  </ApiUnitReference>
  <ApiUnitReference>
    <h3 slot="name" id={ATTRIBUTES.linkFor}><code>{ATTRIBUTES.linkFor}</code></h3>
    <p>
      This attribute is added to the element where <code>toclink</code> action is used and references
      the linked toc element.
    </p>
  </ApiUnitReference>
</section>

<ApiReference href={data.package.apiUrl} />

<img
  src={endImg}
  alt="cat table of contents"
  width="300"
  height="221"
  loading="lazy"
  decoding="async"
/>

<p>Happy making table of contents! üë®‚Äçüíª</p>
